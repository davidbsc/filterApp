# -*- coding: utf-8 -*-
"""Foto3b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UV95-K8Se_np7931_fESzNtVajOBmUbt
"""

import cv2
import math
import numpy as np
from typing import Tuple
from google.colab import files
import io
from PIL import Image

# ==============================================================================
# DEFINIZIONE DELLE FUNZIONI PER IL FILTRO
# La funzione build_googie_lut è stata corretta per una migliore gestione dei colori.
# ==============================================================================

def build_googie_lut(
    sigma_h: float = 20.0,
    warm_h: int = 15,
    cool_h: int = 90,
    pink_h: int = 150,
    sat_boost_warm: float = 1.45,
    sat_boost_cool: float = 1.20,
    sat_boost_pink: float = 1.25,
) -> Tuple[np.ndarray, np.ndarray]:
    """
    Costruisce le tabelle di ricerca (LUT) per tonalità e saturazione per il filtro googie.
    Questa versione utilizza la media vettoriale per calcolare correttamente le tonalità medie,
    prevenendo la deriva dei colori (es. toni della pelle che diventano verdi).
    """
    hue_lut = np.zeros(180, np.uint8)
    sat_lut = np.ones(180, np.float32)
    two_sigma2 = 2.0 * (sigma_h ** 2)

    # Converte le tonalità di destinazione in radianti per la matematica vettoriale
    # La tonalità di OpenCV è 0-179, quindi la mappiamo a 0-358 gradi -> 0-2*pi radianti
    warm_rad = math.radians(warm_h * 2)
    cool_rad = math.radians(cool_h * 2)
    pink_rad = math.radians(pink_h * 2)

    for h in range(180):
        # Calcola la distanza circolare da ogni tonalità di destinazione
        dw = min(abs(h - warm_h), 180 - abs(h - warm_h))
        dc = min(abs(h - cool_h), 180 - abs(h - cool_h))
        dp = min(abs(h - pink_h), 180 - abs(h - pink_h))

        # Pesi gaussiani per ogni regione
        w_warm = math.exp(- (dw ** 2) / two_sigma2)
        w_cool = math.exp(- (dc ** 2) / two_sigma2)
        w_pink = math.exp(- (dp ** 2) / two_sigma2)

        # Somma dei pesi per la normalizzazione
        w_sum = w_warm + w_cool + w_pink

        # Se tutti i pesi sono trascurabili, lascia la tonalità/saturazione invariata
        if w_sum < 1e-6:
            hue_lut[h] = h
            sat_lut[h] = 1.0
        else:
            # Pesi normalizzati
            w_warm /= w_sum
            w_cool /= w_sum
            w_pink /= w_sum

            # --- CORREZIONE DELLA MEDIA DELLE TONALITÀ ---
            # Converte in vettori, trova il vettore medio, riconverte in angolo
            avg_x = (w_warm * math.cos(warm_rad) +
                     w_cool * math.cos(cool_rad) +
                     w_pink * math.cos(pink_rad))
            avg_y = (w_warm * math.sin(warm_rad) +
                     w_cool * math.sin(cool_rad) +
                     w_pink * math.sin(pink_rad))

            # Ottiene l'angolo dal vettore medio
            new_hue_rad = math.atan2(avg_y, avg_x)

            # Riconverte in gradi (0-360)
            new_hue_deg = math.degrees(new_hue_rad)
            if new_hue_deg < 0:
                new_hue_deg += 360

            # Converte all'intervallo di tonalità di OpenCV (0-179)
            new_hue = round(new_hue_deg / 2) % 180

            hue_lut[h] = np.uint8(new_hue)
            # --- FINE DELLA CORREZIONE ---

            # Aumento della saturazione ponderato (questa parte è corretta)
            sat_lut[h] = (
                w_warm * sat_boost_warm
                + w_cool * sat_boost_cool
                + w_pink * sat_boost_pink
            )

    return hue_lut, sat_lut


def _smooth_contrast(
    v: np.ndarray,
    mid_boost: float = 1.05,
    shadow_mul: float = 0.93,
    hi_mul: float = 1.06,
) -> np.ndarray:
    """
    Applica una curva di contrasto a S al canale della luminosità (V).
    """
    v_f = v.astype(np.float32)
    t = v_f / 255.0
    smooth = t * t * (3.0 - 2.0 * t)
    boost = shadow_mul + (hi_mul - shadow_mul) * smooth
    v_new = v_f * boost * mid_boost
    return np.clip(v_new, 0, 255).astype(np.uint8)


def apply_googie_vintage(
    bgr_img: np.ndarray,
    hue_lut: np.ndarray = None,
    sat_lut: np.ndarray = None,
    contrast: bool = True,
    **lut_params,
) -> np.ndarray:
    """
    Applica il filtro vintage googie a un'immagine BGR.
    """
    if hue_lut is None or sat_lut is None:
        hue_lut, sat_lut = build_googie_lut(**lut_params)

    hsv = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)

    h_new = hue_lut[h]
    sat_mult = sat_lut[h_new]
    s_new = np.clip(s.astype(np.float32) * sat_mult, 0, 255).astype(np.uint8)

    if contrast:
        v_new = _smooth_contrast(v)
    else:
        v_new = v

    hsv_new = cv2.merge([h_new, s_new, v_new])
    return cv2.cvtColor(hsv_new, cv2.COLOR_HSV2BGR)


# ==============================================================================
# SEZIONE INTERATTIVA PER GOOGLE COLAB
# Questa parte gestisce il caricamento, l'elaborazione e il download.
# ==============================================================================

try:
    # 1. Carica l'immagine
    print("Clicca sul pulsante 'Scegli file' per caricare un'immagine.")
    uploaded = files.upload()

    # Prendi il nome del primo file caricato
    filename = next(iter(uploaded))
    print(f"\nCaricamento di '{filename}' completato.")

    # Leggi i dati dell'immagine in un array numpy con OpenCV
    img_bytes = uploaded[filename]
    nparr = np.frombuffer(img_bytes, np.uint8)
    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

    if img is None:
        raise ValueError("Impossibile leggere l'immagine. Assicurati che sia un formato valido (JPG, PNG, ecc.).")

    # 2. Applica il filtro
    print("Elaborazione dell'immagine in corso...")
    filtered_img = apply_googie_vintage(img)
    print("Filtro applicato con successo!")

    # 3. Prepara il file per il download
    # Costruisci il nuovo nome del file
    name, ext = filename.rsplit('.', 1)
    output_filename = f"{name}_googie.{ext}"

    # Codifica l'immagine elaborata nel formato corretto
    _, img_encoded = cv2.imencode(f'.{ext}', filtered_img)

    # 4. Salva e scarica l'immagine elaborata
    # Prima salviamo il file nel filesystem di Colab
    with open(output_filename, 'wb') as f:
        f.write(img_encoded.tobytes())

    # Ora che il file esiste, possiamo avviare il download
    print(f"Download di '{output_filename}' in corso...")
    files.download(output_filename)
    print("\nOperazione completata!")


except (StopIteration, ValueError) as e:
    # Gestisce il caso in cui l'utente non carichi un file o il file sia corrotto
    print(f"\nErrore: {e}. Esegui di nuovo la cella per riprovare.")
except Exception as e:
    print(f"Si è verificato un errore inaspettato: {e}")

import cv2
import math
import numpy as np
from typing import Tuple
from google.colab import files
from IPython.display import display, Image as IPImage
import os

# ==============================================================================
# INIZIO DEL CODICE ORIGINALE (Funzioni di elaborazione dell'immagine)
# Tutte le funzioni del tuo script originale sono state copiate qui.
# ==============================================================================

def build_googie_lut(
    sigma_h: float = 20.0,
    warm_h: int = 15,
    cool_h: int = 90,
    pink_h: int = 150,
    sat_boost_warm: float = 1.45,
    sat_boost_cool: float = 1.20,
    sat_boost_pink: float = 1.25,
) -> Tuple[np.ndarray, np.ndarray]:
    """Construct hue and saturation look‑up tables for the googie filter."""
    hue_lut = np.zeros(180, np.uint8)
    sat_lut = np.ones(180, np.float32)
    two_sigma2 = 2.0 * (sigma_h ** 2)

    for h in range(180):
        dw = min(abs(h - warm_h), 180 - abs(h - warm_h))
        dc = min(abs(h - cool_h), 180 - abs(h - cool_h))
        dp = min(abs(h - pink_h), 180 - abs(h - pink_h))
        w_warm = math.exp(- (dw ** 2) / two_sigma2)
        w_cool = math.exp(- (dc ** 2) / two_sigma2)
        w_pink = math.exp(- (dp ** 2) / two_sigma2)
        w_sum = w_warm + w_cool + w_pink

        if w_sum < 1e-6:
            hue_lut[h] = h
            sat_lut[h] = 1.0
        else:
            w_warm /= w_sum
            w_cool /= w_sum
            w_pink /= w_sum
            new_hue = int(round(w_warm * warm_h + w_cool * cool_h + w_pink * pink_h)) % 180
            hue_lut[h] = np.uint8(new_hue)
            sat_lut[h] = (
                w_warm * sat_boost_warm
                + w_cool * sat_boost_cool
                + w_pink * sat_boost_pink
            )
    return hue_lut, sat_lut

def _smooth_contrast(
    v: np.ndarray,
    mid_boost: float = 1.05,
    shadow_mul: float = 0.93,
    hi_mul: float = 1.06,
) -> np.ndarray:
    """Apply a smooth S‑shaped contrast curve to a value channel."""
    v_f = v.astype(np.float32)
    t = v_f / 255.0
    smooth = t * t * (3.0 - 2.0 * t)
    boost = shadow_mul + (hi_mul - shadow_mul) * smooth
    v_new = v_f * boost * mid_boost
    return np.clip(v_new, 0, 255).astype(np.uint8)

def apply_googie_vintage(
    bgr_img: np.ndarray,
    hue_lut: np.ndarray = None,
    sat_lut: np.ndarray = None,
    contrast: bool = True,
    **lut_params,
) -> np.ndarray:
    """Apply the vintage googie filter to a BGR image."""
    if hue_lut is None or sat_lut is None:
        hue_lut, sat_lut = build_googie_lut(**lut_params)

    hsv = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    h_new = hue_lut[h]
    sat_mult = sat_lut[h_new]
    s_new = np.clip(s.astype(np.float32) * sat_mult, 0, 255).astype(np.uint8)

    if contrast:
        v_new = _smooth_contrast(v)
    else:
        v_new = v

    hsv_new = cv2.merge([h_new, s_new, v_new])
    return cv2.cvtColor(hsv_new, cv2.COLOR_HSV2BGR)

# ==============================================================================
# FINE DEL CODICE ORIGINALE
# ==============================================================================


# ==============================================================================
# NUOVA SEZIONE PER GOOGLE COLAB
# Questa parte gestisce il caricamento, l'elaborazione e il download dei file.
# ==============================================================================

def process_image_in_colab():
    """
    Funzione principale per Colab:
    1. Chiede all'utente di caricare un'immagine.
    2. Applica il filtro Googie Vintage.
    3. Mostra l'immagine originale e quella filtrata.
    4. Scarica l'immagine filtrata.
    """
    print("Seleziona un'immagine da caricare:")
    # Apre la finestra di dialogo per il caricamento dei file
    uploaded = files.upload()

    # Controlla se è stato caricato almeno un file
    if not uploaded:
        print("\nNessun file caricato. Esegui nuovamente la cella per riprovare.")
        return

    # Prende il primo file caricato
    filename = next(iter(uploaded))
    print(f"\nCaricato il file: '{filename}'")

    # Legge i dati dell'immagine caricata in un array NumPy che OpenCV può usare
    nparr = np.frombuffer(uploaded[filename], np.uint8)
    original_img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)

    if original_img is None:
        print("Errore: Impossibile decodificare l'immagine. Assicurati che sia un formato valido (JPG, PNG, etc.).")
        return

    print("Applicazione del filtro Googie Vintage in corso...")
    # Applica il filtro all'immagine
    filtered_img = apply_googie_vintage(original_img)
    print("Filtro applicato con successo.")

    # Mostra le immagini nel notebook (opzionale, ma utile per un confronto)
    print("\nVisualizzazione delle immagini (originale a sinistra, filtrata a destra):")
    # Salva temporaneamente le immagini per visualizzarle
    cv2.imwrite('original_temp.jpg', original_img)
    cv2.imwrite('filtered_temp.jpg', filtered_img)

    # Crea un'immagine combinata per un facile confronto
    h1, w1 = original_img.shape[:2]
    h2, w2 = filtered_img.shape[:2]
    combined_img = np.zeros((max(h1, h2), w1 + w2, 3), np.uint8)
    combined_img[:h1, :w1, :] = original_img
    combined_img[:h2, w1:w1+w2, :] = filtered_img
    cv2.imwrite('combined_temp.jpg', combined_img)
    display(IPImage('combined_temp.jpg'))

    # Prepara il nome del file per il download
    root, ext = os.path.splitext(filename)
    output_filename = f"{root}_googie{ext}"

    # Salva l'immagine filtrata su disco (nel file system temporaneo di Colab)
    cv2.imwrite(output_filename, filtered_img)

    print(f"\nDownload dell'immagine elaborata come '{output_filename}'...")
    # Avvia il download del file nel browser
    files.download(output_filename)

# Esegui la funzione principale
process_image_in_colab()
