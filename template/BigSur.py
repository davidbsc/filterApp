# -*- coding: utf-8 -*-
"""3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7WdOKahZ4NrBXY84PXTlgzvd1tSOG4n
"""

# -*- coding: utf-8 -*-
# Import delle librerie necessarie
import cv2
import numpy as np
import ipywidgets as widgets
from IPython.display import display, clear_output
import io
from PIL import Image
import functools

# --- CREAZIONE DELL'INTERFACCIA UTENTE (WIDGETS) ---

# 1. Bottone per il caricamento dell'immagine
uploader = widgets.FileUpload(
    accept='image/*',
    description='Carica Immagine',
    button_style='primary'
)

# 2. Selettore di colore per lo sfondo
background_color_picker = widgets.ColorPicker(
    concise=False,
    description='Colore Sfondo',
    value='#8a8a8a', # Grigio di default
    style={'description_width': 'initial'}
)

# 3. Contenitore per i selettori di colore dinamici
color_rows_box = widgets.VBox([])

# 4. Bottone per aggiungere nuovi selettori di colore
add_color_button = widgets.Button(
    description="+ Aggiungi Colore",
    button_style='success',
    icon='plus'
)

# 5. Box di output per l'immagine
output_box = widgets.Output()

# --- FUNZIONE PRINCIPALE DI ELABORAZIONE ---

def apply_color_splash(uploaded_file, target_colors_hex, sigmas, background_hex_color):
    """
    Applica l'effetto color splash usando una lista di colori e sigma.
    """
    with output_box:
        clear_output(wait=True)

        if not uploaded_file or not target_colors_hex:
            print("Per favore, carica un'immagine per iniziare.")
            return

        try:
            # Legge l'immagine caricata
            file_info = next(iter(uploaded_file.values()))
            content = file_info['content']
            pil_image = Image.open(io.BytesIO(content)).convert('RGB')
            original_image = np.array(pil_image)
            original_image_bgr = cv2.cvtColor(original_image, cv2.COLOR_RGB2BGR)
            image_lab = cv2.cvtColor(original_image_bgr, cv2.COLOR_BGR2LAB)
            L, a, b = cv2.split(image_lab)

            # Inizializza una maschera combinata vuota
            combined_mask = np.zeros(original_image_bgr.shape[:2], dtype=np.float32)

            # --- Calcolo della maschera combinata per tutti i colori ---
            for target_hex, sigma in zip(target_colors_hex, sigmas):
                # Converte il colore target in formato LAB
                hex_color = target_hex.lstrip('#')
                rgb_color = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
                target_rgb_pixel = np.uint8([[rgb_color]])
                target_lab_pixel = cv2.cvtColor(target_rgb_pixel, cv2.COLOR_RGB2LAB)[0][0]
                target_L, target_a, target_b = target_lab_pixel.astype(np.float32)

                # Calcola la distanza di colore (Delta E)
                delta_E = np.sqrt(
                    (L.astype(np.float32) - target_L)**2 +
                    (a.astype(np.float32) - target_a)**2 +
                    (b.astype(np.float32) - target_b)**2
                )

                # Calcola la maschera per il colore corrente
                current_mask = np.exp(-(delta_E**2) / (2 * sigma**2))

                # Aggiorna la maschera combinata prendendo il valore massimo per ogni pixel.
                # Questo assicura che se un pixel è vicino a più colori, viene preservato
                # con la "forza" della sua corrispondenza migliore.
                combined_mask = np.maximum(combined_mask, current_mask)

            mask_3d = np.stack([combined_mask]*3, axis=-1)

            # --- Creazione dello sfondo colorato ---
            grayscale_image = cv2.cvtColor(original_image_bgr, cv2.COLOR_BGR2GRAY)
            bg_hex = background_hex_color.lstrip('#')
            bg_rgb = tuple(int(bg_hex[i:i+2], 16) for i in (0, 2, 4))
            bg_bgr_pixel = np.uint8([[(bg_rgb[2], bg_rgb[1], bg_rgb[0])]])
            bg_hsv_pixel = cv2.cvtColor(bg_bgr_pixel, cv2.COLOR_BGR2HSV)[0][0]
            target_H, target_S, _ = bg_hsv_pixel

            h_channel = np.full_like(grayscale_image, target_H, dtype=np.uint8)
            s_channel = np.full_like(grayscale_image, target_S, dtype=np.uint8)
            v_channel = grayscale_image
            tinted_hsv_background = cv2.merge([h_channel, s_channel, v_channel])
            tinted_bgr_background = cv2.cvtColor(tinted_hsv_background, cv2.COLOR_HSV2BGR)

            # --- Unione delle immagini ---
            blended_image = (original_image_bgr.astype(np.float32) * mask_3d +
                             tinted_bgr_background.astype(np.float32) * (1 - mask_3d))
            final_image_bgr = blended_image.astype(np.uint8)
            final_image_rgb = cv2.cvtColor(final_image_bgr, cv2.COLOR_BGR2RGB)

            display(Image.fromarray(final_image_rgb))

        except Exception as e:
            print(f"Si è verificato un errore: {e}")

# --- GESTIONE DELL'INTERFACCIA DINAMICA ---

def get_current_values_and_process():
    """Raccoglie i valori da tutti i widget e avvia l'elaborazione."""
    if not uploader.value:
        apply_color_splash({}, [], [], background_color_picker.value)
        return

    target_colors = [row.children[0].value for row in color_rows_box.children]
    sigmas = [row.children[1].value for row in color_rows_box.children]

    apply_color_splash(
        uploader.value,
        target_colors,
        sigmas,
        background_color_picker.value
    )

def add_color_row(b=None):
    """Aggiunge una nuova riga di selettore colore e slider sigma."""
    new_color_picker = widgets.ColorPicker(
        concise=False, description='Colore', value='#4CAF50', style={'description_width': 'initial'}
    )
    new_sigma_slider = widgets.FloatSlider(
        value=25.0, min=1.0, max=150.0, step=1.0, description='Sigma:', readout_format='.1f', style={'description_width': 'initial'}
    )

    # Aggiunge il listener per l'aggiornamento automatico
    new_color_picker.observe(lambda change: get_current_values_and_process(), names='value')
    new_sigma_slider.observe(lambda change: get_current_values_and_process(), names='value')

    remove_button = widgets.Button(description="Rimuovi", button_style='danger', icon='trash')

    # Crea la riga orizzontale
    row = widgets.HBox([new_color_picker, new_sigma_slider, remove_button])

    def remove_row(b, row_to_remove):
        # Rimuove la riga dalla lista e aggiorna l'interfaccia
        current_rows = list(color_rows_box.children)
        current_rows.remove(row_to_remove)
        color_rows_box.children = tuple(current_rows)
        get_current_values_and_process() # Rielabora l'immagine

    # Collega la funzione di rimozione al pulsante, passando un riferimento alla riga stessa
    remove_button.on_click(functools.partial(remove_row, row_to_remove=row))

    # Aggiunge la nuova riga all'interfaccia
    color_rows_box.children = tuple(list(color_rows_box.children) + [row])
    get_current_values_and_process()

# Collega la funzione al pulsante "+ Aggiungi Colore"
add_color_button.on_click(add_color_row)

# Aggiunge i listener per l'uploader e il colore di sfondo
uploader.observe(lambda change: get_current_values_and_process(), names='value')
background_color_picker.observe(lambda change: get_current_values_and_process(), names='value')

# --- VISUALIZZAZIONE DELL'INTERFACCIA COMPLETA ---

# Layout dell'header con i controlli principali
header_controls = widgets.VBox([
    widgets.HTML("<h1>Color Splash Interattivo (Multi-Colore)</h1>"),
    widgets.HTML("<p>Carica un'immagine, aggiungi i colori da preservare con le relative tolleranze e scegli un colore di sfondo.</p>"),
    widgets.HBox([uploader, background_color_picker])
])

# Assembla l'interfaccia finale
ui = widgets.VBox([
    header_controls,
    color_rows_box,
    add_color_button,
    output_box
])

# Aggiunge la prima riga di colore di default all'avvio
add_color_row()
# Modifica il valore di default per il primo colore
color_rows_box.children[0].children[0].value = '#a75d5a'
# Nasconde il pulsante "Rimuovi" per la prima riga per assicurare che ce ne sia sempre almeno una
color_rows_box.children[0].children[2].layout.display = 'none'


display(ui)
get_current_values_and_process()